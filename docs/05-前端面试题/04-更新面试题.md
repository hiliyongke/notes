# 更新面试题

## 什么是异步函数？

js 是单线程语言，只能同时处理一个任务，如果请求的是后端，这个响应可能是几秒之后才响应，所以要先跳过这个任务，继续向下执行。必须等主进程全部执行完成之后再执行异步函数。就算主进程再慢，也要等主进程全部加载完成之后再加载。

## 微任务和宏任务是什么？

因为 js 是单线程语言，它就好比是一个人在工作，但是同一时间只能做一项工作，所以就产生了任务队列，需要将接下来的工作都放到任务队列里面编排，干完一项任务之后再进行下一项任务。

但是任务队列还会分成三种：`主任务队列、微任务队列、宏任务队列`，每种不同的任务类型会放在不同的任务队列中，同步代码从上到下，都会放在 `主任务队列`中；异步函数，如：`setTimeout`、`setInterval`，属于异步函数，会放在 `宏任务队列`；那么`微任务`呢，指的就是 **Promise 通过 .then() 的回调**。

任务也是存在优先级的，他们之间的优先级为：`主任务队列 > 微任务队列 > 宏任务队列`

例如下面代码演示：

```js
setTimeout(() => {
  console.log('setTimeout') // 宏任务
}, 0)

new Promise((resolve) => {
  console.log('Promise') // 这里也是主进程
  resolve('成功了')
}).then((res) => {
  console.log(res) // 微任务
})

console.log('主进程') // 主进程

// 日志：
// Promise
// 主进程
// 成功了
// setTimeout
```

## node 有什么优势？

node 是一个 javascript 的运行环境，使用这个环境去搭建上层的一些应用。可以使用它打、运行，或者当作服务器去运行一些工具，开发环境，这是 node 的主要作用。

node 处理[高并发](https://blog.csdn.net/weixin_42476601/article/details/82220027)是有天然优势的，它的机制就是：单线程、事件循环，事件驱动这个机制可以处理高并发请求，但是 node 主要是做服务器渲染。

## new 操作符都做了什么？

- 在内存中新建一个对象
- 这个新对象内部的 `[[prototype]]` 特性被赋值为函数的 `prototype` 属性
- 构造函数内部的 `this` 被赋值为这个新对象（即 `this` 指向新对象）
- 指向构造函数内部的代码（给新对象添加属性）
- 如果构造函数没有返回其它对象，那么就返回刚创建的新对象

## 输入 url 回车这一过程中发生了什么？

主要有三个步骤

1. ip 地址的寻址

首先在浏览器的缓存里查找，有没有这个 ip 地址；然后到 host 文件里查找，有没有配置这个域名的 ip 地址；然后到路由器的缓存里查找，有没有这个域名的 ip 地址；最后到 dns 服务器去查找，如果没有，就到更高一级的 dns 服务器去查找，直到找到为止。

2. 请求数据

首先向这个 ip 地址发起连接请求，进行 tcp 的三次握手，连接建立成功之后呢，服务器就会返回相应的数据。然后就会进行 tcp 断开连接的四次挥手。

3. 页面展现

首先是解析 html 文件，创建 dom 树，然后解析 css，形成 css 对象模型，然后将 css 和 dom 合并，构建渲染树，最后就是布局和绘制渲染树。

## 怎么做性能优化？

## 如何中断已发出去的请求？

## localStorage 怎么设置过期时间？
